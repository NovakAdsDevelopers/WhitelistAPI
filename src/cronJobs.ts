// src/automations/cronJobs.ts
import cron from "node-cron";
import { prisma } from "./database";
import {
  associateBMsTOAdAccounts,
  createORupdateBMs,
} from "./meta/services/BusinessManager";
import { recalcularGastosDiarios } from "./meta/services/gastoDiario";
import { saveOrUpdateAdAccounts } from "./meta/services/Account";
import { fetchAllAdAccounts } from "./meta/services/AdAccounts";

// Se voc√™ tiver fun√ß√µes auxiliares importadas de outros m√≥dulos
// como "autoDisparoAlertas" ou "ajusteDiarioLimitesAlerta", importe-as aqui.
let isSyncRunning = false;

export function startCronJobs() {

  console.log("üïì Iniciando automa√ß√µes CRON...");


  // CRON: Atualiza√ß√µes de gasto de contas a cada 30 minutos
  cron.schedule("*/30 * * * *", async () => {
    if (isSyncRunning) {
      console.warn(
        "‚è≥ CRON: Sincroniza√ß√£o j√° em andamento. Ignorando nova execu√ß√£o."
      );
      return;
    }

    isSyncRunning = true;
    const startTime = new Date();
    console.log("üîÑ [CRON] Iniciando sincroniza√ß√£o geral das contas...");

    try {
      const tokens = await prisma.token.findMany();
      console.log(`üîπ [CRON] ${tokens.length} tokens encontrados.`);

      const results: Record<string, any> = {};

      for (const token of tokens) {
        try {
          console.log(`üîÑ [CRON] Sincronizando contas para: ${token.title}`);
          results[token.title] = await fetchAllAdAccounts(token.token);
        } catch (err) {
          console.error(`‚ùå [CRON] Falha ao sincronizar ${token.title}:`, err);
        }
      }

      console.log("‚úÖ [CRON] Sincroniza√ß√£o de contas conclu√≠da com sucesso.");
    } catch (error: any) {
      console.error(
        "‚ùå [CRON] Erro na sincroniza√ß√£o geral:",
        error.message || error
      );
    } finally {
      isSyncRunning = false;
      const duration = ((Date.now() - startTime.getTime()) / 1000).toFixed(1);
      console.log(`üïí [CRON] Execu√ß√£o finalizada (${duration}s).`);
    }
  });

  // CRON: Ajuste de alertas a cada 30 minutos
  // cron.schedule("*/30 * * * *", async () => {
  //   try {
  //     console.log("‚ö†Ô∏è CRON: Disparando alertas autom√°ticos...");
  //     await autoDisparoAlertas();
  //   } catch (error) {
  //     console.error("‚ùå CRON erro ao disparar alertas:", error);
  //   }
  // });

  // CRON: Tarefa √†s 9h para ajustes di√°rios
  // cron.schedule("0 9 * * *", async () => {
  //   console.log("‚òÄÔ∏è CRON: Ajuste de limites di√°rios...");
  //   try {
  //     await Promise.all([ajusteDiarioLimitesAlerta()]);
  //   } catch (error) {
  //     console.error("‚ùå CRON erro no ajuste de limites:", error);
  //   }
  // });

  // CRON: Verifica, cria ou atualiza BMs todo dia 3 √† meia-noite
  cron.schedule("0 0 3 * *", async () => {
    console.log("üïõ Iniciando atualiza√ß√£o de BMs no dia 3 √† meia-noite...");
    try {
      const tokensList = await prisma.token.findMany();

      for (const token of tokensList) {
        console.log(`üîπ Atualizando BM do token: ${token.title}`);
        await createORupdateBMs(token.token, token.id);
      }

      console.log("‚úÖ Todas as BMs foram atualizadas com sucesso!");
    } catch (error) {
      console.error("‚ùå Erro ao atualizar BMs:", error);
    }
  });

  // CRON: Recalcular gastos diariamente √†s 0h
  cron.schedule("0 0 * * *", async () => {
    try {
      await recalcularGastosDiarios();
      console.log("üìä CRON: Recalculo de gastos conclu√≠do.");

      const allBMs = await prisma.bM.findMany({
        include: { token: true },
      });

      for (const bm of allBMs) {
        const BMId = bm.BMId;
        const token = bm.token?.token;

        if (!token) {
          console.warn(`‚ö†Ô∏è BM ${BMId} n√£o possui token associado. Ignorando.`);
          continue;
        }

        console.log(`üîπ Associando BM ${BMId} com seu token.`);
        await associateBMsTOAdAccounts(BMId, token);
      }
    } catch (error) {
      console.error("‚ùå CRON erro ao recalcular gastos:", error);
    }
  });
}

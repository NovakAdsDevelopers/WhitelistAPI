import express, { Application } from "express";
import cron from "node-cron";
import axios from "axios";
import dotenv from "dotenv";
import { PrismaClient } from "@prisma/client";
import { Decimal } from "@prisma/client/runtime/library";
import cors from "cors";

dotenv.config();

const app = express();
app.use(
  cors({
    origin: "*",
    credentials: true,
  })
);
const prisma = new PrismaClient();
const token = process.env.TOKEN_ACCESS_META;
const API_URL = `${process.env.META_MARKETING_API_URL}/me/adaccounts`;

async function saveOrUpdateAdAccounts(adAccounts: any[]) {
  console.log(`üîπ Processando ${adAccounts.length} contas recebidas...`);

  for (const account of adAccounts) {
    console.log(
      `üîç Verificando conta: ${account.account_id} - ${account.name}`
    );

    try {
      const existingAccount = await prisma.adAccount.findUnique({
        where: { id: account.account_id },
      });

      const amountSpentDecimal = new Decimal(account.amount_spent || "0");
      const agora = new Date().toISOString();

      if (existingAccount) {
        const hasChanges =
          existingAccount.nome !== account.name ||
          existingAccount.status !== account.account_status ||
          existingAccount.moeda !== account.currency ||
          existingAccount.fusoHorario !== account.timezone_name ||
          existingAccount.limiteGasto !== account.spend_cap ||
          existingAccount.saldoMeta !== account.balance ||
          !existingAccount.gastoTotal.equals(amountSpentDecimal);

        if (hasChanges) {
          console.log(`üìù Atualizando conta ${account.account_id}...`);
          await prisma.adAccount.update({
            where: { id: account.account_id },
            data: {
              nome: account.name,
              status: account.account_status,
              moeda: account.currency,
              fusoHorario: account.timezone_name,
              gastoTotal: amountSpentDecimal,
              limiteGasto: account.spend_cap,
              saldoMeta: account.balance,
              ultimaSincronizacao: agora,
            },
          });
          console.log(`‚úÖ Conta ${account.account_id} atualizada com sucesso.`);
        } else {
          console.log(`‚úÖ Conta ${account.account_id} j√° est√° atualizada.`);
        }
      } else {
        console.log(`üÜï Criando nova conta ${account.account_id}...`);
        await prisma.adAccount.create({
          data: {
            id: account.account_id,
            nome: account.name,
            status: account.account_status,
            moeda: account.currency,
            fusoHorario: account.timezone_name,
            gastoTotal: amountSpentDecimal,
            gastoAPI: account.amount_spent,
            limiteGasto: account.spend_cap,
            saldoMeta: account.balance,
            ultimaSincronizacao: agora,
          },
        });
        console.log(`‚úÖ Conta ${account.account_id} cadastrada com sucesso.`);
      }
    } catch (error) {
      console.error(`‚ùå Erro ao processar conta ${account.account_id}:`, error);
    }
  }
}

// Busca contas com pagina√ß√£o
async function fetchAllAdAccounts(url: string) {
  console.log("üîÑ Iniciando busca de contas de an√∫ncio no Meta API...");
  try {
    let nextUrl: string | null = url;
    let totalAccounts = 0;

    while (nextUrl) {
      console.log(`üì° Fazendo requisi√ß√£o para: ${nextUrl}`);
      const response: any = await axios.get(nextUrl, {
        params: {
          access_token: token,
          fields:
            "name,account_id,account_status,currency,timezone_name,amount_spent,spend_cap,balance",
          limit: 25,
        },
      });

      const data = response.data;
      if (data.data && data.data.length > 0) {
        totalAccounts += data.data.length;
        await saveOrUpdateAdAccounts(data.data);
      }

      nextUrl = data.paging?.next || null;
    }

    console.log(
      `‚úÖ Sincroniza√ß√£o conclu√≠da. Total de contas processadas: ${totalAccounts}`
    );
    return { totalAccounts }; // ‚Üê aqui
  } catch (error) {
    console.error("‚ùå Erro ao buscar contas de an√∫ncio:", error);
    throw error; // ‚Üê aqui
  }
}

async function fetchAdAccountsByIds(accountIds: string[]) {
  console.log(`üîç Iniciando sincroniza√ß√£o de contas espec√≠ficas:`, accountIds);

  const results: any[] = [];

  for (const accountId of accountIds) {
    try {
      const response = await axios.get(
        `https://graph.facebook.com/v17.0/act_${accountId}`,
        {
          params: {
            access_token: token,
            fields:
              "name,account_id,account_status,currency,timezone_name,amount_spent,spend_cap,balance",
          },
        }
      );

      if (response.data) {
        results.push({
          ...response.data,
          account_id: accountId,
        });
        console.log(`‚úÖ Conta ${accountId} carregada com sucesso.`);
      }
    } catch (error) {
      console.error(`‚ùå Erro ao buscar conta ${accountId}:`, error);
    }
  }

  if (results.length > 0) {
    await saveOrUpdateAdAccounts(results);
  } else {
    console.log("‚ö†Ô∏è Nenhuma conta v√°lida encontrada para atualizar.");
  }
}

// Sincroniza√ß√£o geral manual
app.get("/sync-ads", async (req, res) => {
  console.log("üñ•Ô∏è Rota /sync-ads acionada!");
  try {
    const result: any = await fetchAllAdAccounts(API_URL); // deve lan√ßar erro se falhar
    console.log("üîÅ Resultado da sincroniza√ß√£o:", result);

    // Protege contra retorno undefined/null
    if (!result) {
      throw new Error("Nenhum resultado retornado da sincroniza√ß√£o.");
    }

    res
      .status(200)
      .json({ message: "‚úÖ Sincroniza√ß√£o conclu√≠da com sucesso.", result });
  } catch (error: any) {
    console.error("‚ùå Erro na sincroniza√ß√£o:", error);
    res
      .status(500)
      .json({ error: error.message || "Erro ao iniciar a sincroniza√ß√£o" });
  }
});

// Sincroniza√ß√£o manual de uma conta espec√≠fica
app.get("/sync-ads/:ad_account_id", async (req, res) => {
  const { ad_account_id } = req.params;
  console.log(`üñ•Ô∏è Rota /sync-ads/${ad_account_id} acionada!`);

  if (!ad_account_id || typeof ad_account_id !== "string") {
    return res
      .status(400)
      .json({ error: "ID da conta de an√∫ncio inv√°lido ou n√£o fornecido." });
  }

  try {
    await fetchAdAccountsByIds([ad_account_id]); // usa sua fun√ß√£o atual
    res.status(200).json({
      message: `‚úÖ Sincroniza√ß√£o da conta ${ad_account_id} conclu√≠da com sucesso.`,
    });
  } catch (error: any) {
    console.error(`‚ùå Erro ao sincronizar a conta ${ad_account_id}:`, error);
    res.status(500).json({
      error: error.message || "Erro ao sincronizar a conta de an√∫ncio.",
    });
  }
});

// Sincroniza√ß√£o manual de contas especificas

app.post("/sync-ads-by-ids", async (req, res) => {
  const { account_ids } = req.body;

  console.log("üñ•Ô∏è Rota /sync-ads-by-ids acionada com:", account_ids);

  if (!Array.isArray(account_ids) || account_ids.length === 0) {
    return res
      .status(400)
      .json({ error: "√â necess√°rio fornecer um array de IDs de contas." });
  }

  // Remove "act_" caso os IDs venham com o prefixo
  const cleanIds = account_ids.map((id: string) =>
    id.startsWith("act_") ? id.replace("act_", "") : id
  );

  try {
    await fetchAdAccountsByIds(cleanIds);
    res.status(200).json({
      message: "‚úÖ Sincroniza√ß√£o das contas conclu√≠da com sucesso.",
      synchronized_accounts: cleanIds,
    });
  } catch (error: any) {
    console.error("‚ùå Erro na sincroniza√ß√£o de contas espec√≠ficas:", error);
    res.status(500).json({
      error: error.message || "Erro ao sincronizar as contas.",
    });
  }
});

// Busca e salva gasto di√°rio dos √∫ltimos 7 dias
async function fetchAdAccountDailySpend(accountId: string) {
  const today = new Date().toISOString().split("T")[0]; // formato: "YYYY-MM-DD"

  let url = `https://graph.facebook.com/v22.0/act_${accountId}/insights?access_token=${token}&fields=spend,date_start&time_increment=1&time_range={"since":"2023-01-01","until":"${today}"}`;

  try {
    let hasNextPage = true;
    let page = 1;

    while (hasNextPage) {
      console.log(`üìÑ Buscando p√°gina ${page} de gastos para conta ${accountId}...`);

      const response = await axios.get(url);

      const insights = response.data?.data;
      if (!insights || insights.length === 0) break;

      for (const day of insights) {
        const date = new Date(day.date_start);
        const spend = parseFloat(day.spend || "0");

        await prisma.gastoDiario.upsert({
          where: {
            contaAnuncioId_data: {
              contaAnuncioId: accountId,
              data: date,
            },
          },
          update: {
            gasto: spend.toString(),
          },
          create: {
            contaAnuncioId: accountId,
            data: date,
            gasto: spend.toString(),
          },
        });

        console.log(`üíæ Gasto de ${spend} salvo para ${accountId} em ${day.date_start}`);
      }

      if (response.data?.paging?.next) {
        url = response.data.paging.next;
        page++;
      } else {
        hasNextPage = false;
      }
    }

    // Soma de todos os gastos para atualizar gastoTotal
    console.log(`üìä Recalculando gasto total para a conta ${accountId}...`);
    const totalGasto = await prisma.gastoDiario.aggregate({
      _sum: {
        gasto: true,
      },
      where: {
        contaAnuncioId: accountId,
      },
    });

    const total = Math.floor(totalGasto._sum.gasto ?? 0).toString();

    await prisma.adAccount.update({
      where: { id: accountId },
      data: {
        gastoTotal: total,
      },
    });

    console.log(`üí∞ Gasto total atualizado: ${total}`);
  } catch (error) {
    console.error(`‚ùå Erro ao buscar gasto di√°rio da conta ${accountId}:`, error);
  }
}

// Executa sincroniza√ß√£o di√°ria para todas as contas
async function fetchDailySpendForAllAccounts() {
  const accounts = await prisma.adAccount.findMany();
  for (const acc of accounts) {
    await fetchAdAccountDailySpend(acc.id);
  }
}

// Rota manual para sincronizar gasto di√°rio
app.get("/sync-daily-spend", async (req, res) => {
  try {
    await fetchDailySpendForAllAccounts();
    res.json({ message: "‚úÖ Gastos di√°rios sincronizados com sucesso." });
  } catch (error) {
    res.status(500).json({ error: "Erro ao sincronizar gastos di√°rios." });
  }
});

async function getInsights(
  accountId: string,
  startDate?: string,
  endDate?: string
) {
  const url = `https://graph.facebook.com/v17.0/act_${accountId}/insights`;

  const params: any = {
    access_token: token,
    fields: "spend,date_start",
    time_increment: 1,
    limit: 25,
  };

  if (startDate && endDate) {
    params.time_range = JSON.stringify({
      since: startDate,
      until: endDate,
    });
  } else {
    params.date_preset = "maximum";
  }

  try {
    const response = await axios.get(url, { params });

    const insights = response.data;

    if (!insights || insights.length === 0) {
      console.log(`‚ö†Ô∏è Nenhum insight encontrado para a conta ${accountId}`);
      return [];
    }

    console.log(`üìà Insights obtidos para a conta ${accountId}:`, insights);
    return insights;
  } catch (error) {
    console.error(
      `‚ùå Erro ao obter insights da conta ${accountId}:`,
      error || error
    );
    return [];
  }
}

// Sincroniza√ß√£o autom√°tica: Contas + Gastos di√°rios a cada 8 horas
cron.schedule("0 */8 * * *", async () => {
  console.log("‚è≥ Executando sincroniza√ß√£o autom√°tica...");
  // await fetchAllAdAccounts(API_URL);
  // await fetchDailySpendForAllAccounts();
});

// Execu√ß√£o ao iniciar
(async () => {
  console.log("üöÄ Sincroniza√ß√£o inicial ao iniciar a API...");
  // await fetchAllAdAccounts(API_URL);
  // await fetchDailySpendForAllAccounts();
})();

export { app as metaSync };
